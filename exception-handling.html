<h2 class="section-heading" id="exception-handling">
    <span>1. Exception Handling</span>
</h2>
<p class="description">
    Exception handling is a critical concept in programming that allows developers to anticipate and manage runtime errors or unexpected situations that could disrupt the normal flow of a program. In Python, exception handling is implemented using the `try`, `except`, and `finally` blocks. These constructs help ensure that your program continues to run smoothly even when an error occurs, providing better control over program execution and enhancing the user experience.
    <br><br>
    When an error occurs in a program, it can interrupt the flow of execution, causing the program to crash. Exception handling provides a way to catch these errors, handle them in a controlled manner, and prevent the program from terminating unexpectedly. This is particularly important in complex applications where stability is essential, such as web applications, financial systems, or embedded software.
    <br><br>
    Python's approach to exception handling is straightforward and readable, making it accessible even for beginners. With well-defined exception types, custom error messages, and the ability to clean up resources, Python offers powerful tools to handle errors gracefully.
</p>

<h2 class="section-heading" id="try-except">
    <span>2. Try/Except Blocks</span>
</h2>
<p class="description">
    The `try` and `except` blocks are the cornerstone of exception handling in Python. The basic idea is to "try" executing a block of code and "except" certain exceptions (errors) if they occur. This approach allows you to handle errors gracefully and take appropriate actions when needed.
    <br><br>
    <strong>Try</strong> The code within the `try` block is executed normally. If no errors occur, the program continues as usual.
    <br><br>
    <strong>Except</strong> If an error occurs within the `try` block, the program jumps to the `except` block, where the error is caught, and the appropriate action is taken.
    <br><br>
    <strong>Example</strong> Consider a scenario where a program attempts to divide two numbers, and you need to handle a possible division by zero error:
    <pre class="code-block">
    try:
        result = 10 / 0
    except ZeroDivisionError:
        print("Cannot divide by zero.")
    </pre>
    In this case, the program will not crash; instead, it will catch the `ZeroDivisionError` and print an appropriate message.
</p>

<h2 class="section-heading" id="finally-block">
    <span>3. Finally Block</span>
</h2>
<p class="description">
    The `finally` block is an optional part of exception handling in Python. It allows you to execute certain code after the `try` block, regardless of whether an exception was raised or not. This is useful for ensuring that cleanup tasks, like closing files or releasing resources, are always executed, even if an error occurs during the program's execution.
    <br><br>
    <strong>Finally</strong> Code within the `finally` block runs after the `try` and `except` blocks, regardless of whether an exception was raised or not. It is commonly used for resource management tasks like closing database connections or files.
    <br><br>
    <strong>Example</strong> Here's how you can use the `finally` block to ensure that a file is always closed after it is processed:
    <pre class="code-block">
    try:
        file = open("example.txt", "r")
        # Perform file operations
    except FileNotFoundError:
        print("File not found.")
    finally:
        file.close()
        print("File has been closed.")
    </pre>
    In this example, the file is guaranteed to be closed even if an error occurs while reading the file.
</p>

<h2 class="section-heading" id="exception-types">
    <span>4. Common Exception Types</span>
</h2>
<p class="description">
    Python provides several built-in exception types to handle a wide range of common errors. Some of the most frequently encountered exceptions include:
    <br><br>
    <strong>ZeroDivisionError</strong> Raised when dividing by zero.
    <strong>FileNotFoundError</strong> Raised when a file is not found.
    <strong>ValueError</strong> Raised when a function receives an argument of the correct type but an inappropriate value.
    <strong>IndexError</strong> Raised when attempting to access an element from a list using an invalid index.
    <strong>KeyError</strong> Raised when a dictionary key is not found.
    <br><br>
    By catching these exceptions, you can prevent your program from crashing and provide meaningful feedback to users.
    <br><br>
    <strong>Example</strong> Catching multiple exceptions in one block:
    <pre class="code-block">
    try:
        num = int(input("Enter a number: "))
        result = 10 / num
    except ValueError:
        print("Please enter a valid number.")
    except ZeroDivisionError:
        print("Cannot divide by zero.")
    </pre>
    In this example, the program handles both invalid input and division by zero gracefully.
</p>

<h2 class="section-heading" id="real-world-scenarios">
    <span>5. Real-World Scenarios</span>
</h2>
<p class="description">
    Exception handling is widely used in various real-world applications to enhance reliability and user experience:
    <br><br>
    <strong>Web Development</strong> Handling errors related to user input, database connectivity, and server issues. For example, when a user enters invalid data in a form, the program can catch the error and show a helpful message instead of crashing.
    <br>
    <strong>Data Processing</strong> Ensuring that data is processed without errors, such as catching issues with missing or corrupted data files.
    <br>
    <strong>Game Development</strong> Handling unexpected events like a network failure or invalid game state during gameplay. For instance, catching network connection errors during an online multiplayer session.
    <br>
    <strong>Automation and IoT</strong> Ensuring that automated tasks, such as device communication or sensor readings, continue even when errors occur in individual tasks or components.
</p>

<h2 class="section-heading" id="example-code">
    <span>6. Example Code</span>
</h2>
<p class="description">
    Here is an example that demonstrates how exception handling can be used in real-world scenarios:
</p>

<pre class="code-block">
# Example: Bank Transaction
try:
    account_balance = float(input("Enter your account balance: "))
    withdrawal_amount = float(input("Enter the withdrawal amount: "))
    
    if withdrawal_amount > account_balance:
        raise ValueError("Insufficient funds.")
    else:
        account_balance -= withdrawal_amount
        print(f"Withdrawal successful. New balance: ${account_balance:.2f}")
except ValueError as e:
    print(f"Error: {e}")
except Exception as e:
    print(f"An unexpected error occurred: {e}")
finally:
    print("Thank you for using our banking service.")

# Example: File Reading
try:
    file = open("data.txt", "r")
    data = file.read()
    print(data)
except FileNotFoundError:
    print("File not found. Please check the file path.")
except IOError:
    print("An error occurred while reading the file.")
finally:
    if 'file' in locals():
        file.close()
    print("File operation completed.")
</pre>

<h2 class="section-heading" id="additional-resources">
    <span>7. Additional Resources</span>
</h2>
<ul class="resource-list">
    <li><a href="https://docs.python.org/3/tutorial/errors.html" target="_blank" rel="noopener">Python Errors and Exceptions</a></li>
    <li><a href="https://docs.python.org/3/library/exceptions.html" target="_blank" rel="noopener">Built-in Exceptions</a></li>
    <li><a href="https://realpython.com/python-exceptions/" target="_blank" rel="noopener">Real Python - Handling Exceptions</a></li>
    <li><a href="https://www.geeksforgeeks.org/python-exception-handling/" target="_blank" rel="noopener">GeeksforGeeks - Exception Handling in Python</a></li>
</ul>
